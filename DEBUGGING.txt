KERNEL DEBUGGING GUIDE
======================

This guide explains how to use the debugging tools and scripts provided for the ARM64 kernel development.

## Quick Start

The main debugging tool is `scripts/debug-qemu.sh` which launches QEMU with GDB server and connects GDB with your chosen script:

```bash
./scripts/debug-qemu.sh <gdb-script>
```

Example:
```bash
./scripts/debug-qemu.sh scripts/comprehensive-mapping-test.gdb
```

## Available Debug Scripts

### 1. comprehensive-mapping-test.gdb
**Purpose**: Thoroughly verifies both identity (TTBR0) and higher-half (TTBR1) page table mappings.

**What it tests**:
- Physical address calculation
- Page table pointer setup
- Complete page table walk for both TTBR0 and TTBR1
- Entry attributes verification
- Memory access through both mappings

**When to use**: After implementing page table setup to verify mappings are correct.

### 2. test-mmu-to-kernel.gdb
**Purpose**: Tests execution flow from MMU enable through to kernel_main jump.

**What it tests**:
- MMU enable sequence
- Execution continues after MMU enable
- Stack pointer setup
- Register state before kernel_main
- Memory access through identity mapping

**When to use**: To verify MMU enable doesn't cause hangs and execution flow is correct.

### 3. test-kernel-main-access.gdb
**Purpose**: Examines what happens when kernel_main tries to access virtual addresses.

**What it tests**:
- kernel_main entry and initial execution
- First virtual address access attempt
- Exception behavior
- Final register state after fault

**When to use**: To understand why kernel_main faults and verify virtual address issues.

### 4. verify-identity-map.gdb
**Purpose**: Basic verification of identity mapping setup.

**What it tests**:
- L0, L1, L2 page table entries for identity mapping
- Physical address mappings
- Basic MMU enable test

**When to use**: Early testing of identity mapping implementation.

### 5. verify-higher-half-map.gdb
**Purpose**: Verifies higher-half mapping configuration.

**What it tests**:
- TTBR1 page table entries
- Virtual to physical mapping for kernel region
- Address translation for 0xFFFF... addresses

**When to use**: After implementing TTBR1 setup.

## Key Addresses and Breakpoints

### Physical Addresses (Identity Mapped)
- `0x40080000` - _start (kernel entry point)
- `0x40080068` - el1_entry
- `0x400801e8` - Just before MMU enable
- `0x400801fc` - After MMU enable
- `0x40080210` - Branch to kernel_main
- `0x40081ae0` - kernel_main

### Virtual Addresses (Higher Half)
- `0xFFFF000040080000` - Virtual _start
- `0xFFFF000040081ae0` - Virtual kernel_main
- `0xFFFF000040084xxx` - .rodata section (string constants)

### Page Table Locations
- `0x40077000` - TTBR0 L0 table
- `0x40078000` - TTBR0 L1 table
- `0x40079000` - TTBR0 L2 table (first 512MB)
- `0x4007a000` - TTBR0 L2 table (second 512MB)
- `0x4007b000` - TTBR1 L0 table
- `0x4007c000` - TTBR1 L1 table
- `0x4007d000` - TTBR1 L2 table

## Common GDB Commands

### Page Table Walking
```gdb
# Check a page table entry
x/gx <table_base> + (<index> * 8)

# Walk page tables for an address
set $l0_idx = (<addr> >> 39) & 0x1FF
set $l1_idx = (<addr> >> 30) & 0x1FF
set $l2_idx = (<addr> >> 21) & 0x1FF

# For TTBR1 (0xFFFF... addresses), L0 index is usually 0x1FE
```

### Register Inspection
```gdb
# Check MMU status
print/x $SCTLR_EL1

# Check page table bases
print/x $TTBR0_EL1
print/x $TTBR1_EL1

# Check translation control
print/x $TCR_EL1
```

### Memory Access Testing
```gdb
# Test identity mapping
x/4i 0x40080000

# Test higher-half mapping
x/4i 0xFFFF000040080000

# Both should show the same instructions if mappings are correct
```

## Debugging Tips

1. **GDB Scripts and Comments**: Don't use inline comments (e.g., `break *0x123 # comment`) in GDB scripts. GDB doesn't parse them correctly.

2. **Connection Issues**: If you see "Connection refused" errors, make sure no other QEMU instances are running:
   ```bash
   pkill qemu-system-aarch64
   ```

3. **Symbol Loading**: The debug-qemu.sh script automatically loads symbols from kernel.elf, so you can use symbolic debugging once in higher half.

4. **Breakpoint Timing**: Set breakpoints using physical addresses during boot, before the jump to higher half.

5. **Exception Vectors**: If execution jumps to addresses like 0x200, 0x280, 0x400, or 0x480, an exception has occurred.

## Creating Custom Debug Scripts

1. Create a new .gdb file in the scripts/ directory
2. Don't include `target remote :1234` - debug-qemu.sh handles connection
3. Use physical addresses for breakpoints during boot phase
4. Include clear echo statements to track progress
5. Always end with `quit` if the script should exit automatically

Example template:
```gdb
# My custom debug script
set pagination off

echo \n=== MY DEBUG TEST ===\n

# Set breakpoint at el1_entry
break *0x40080068
continue

# Your debugging commands here
echo Current PC: 
output/x $pc
echo \n

# Continue or quit
quit
```

## Troubleshooting

### "Cannot access memory" errors
- Check if address is mapped in current page tables
- Verify you're using correct address space (physical vs virtual)
- Ensure MMU is enabled if accessing virtual addresses

### Execution hangs
- Check if you're stuck in exception handler
- Verify page table entries are correct
- Check for infinite loops in exception vectors

### Wrong addresses in disassembly
- Remember kernel.elf uses virtual addresses
- Use physical addresses for breakpoints before higher-half jump
- The debug scripts handle most address translation automatically